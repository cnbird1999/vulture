import re
from collections import namedtuple

Instruction = namedtuple('Instruction', ['mnemonic', 'is_mnemonic_exact', 'classification', 'encoding', 'dest_ptr_regs'])

'''
classifications:
BLOCK_DATA_MOVE
BRANCH
CALCULATION
DATA_EXCHANGE
DATA_MOVE
INTERRUPT
RETURN
STACK_POP
STACK_PUSH

encodings:
COMBO_OPERANDS
COMBO_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE
COMBO_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE | DEST_OPERAND_IS_UNAFFECTED
COMBO_OPERANDS | DEST_OPERAND_IS_UNAFFECTED
COMBO_OPERANDS | DEST_OPERAND_IS_UNAFFECTED | DEST_OPERAND_IS_IMPLIED_SOURCE
DEST_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE
DEST_OPERANDS | SOURCE_REGISTER  | DEST_OPERAND_IS_IMPLIED_SOURCE
DEST_REGISTER
DEST_REGISTER | SOURCE_OPERANDS
NO_OPERANDS
SOURCE_OPERANDS
SOURCE_OPERANDS_ONLY
SOURCE_POINTER | DEST_REGISTER
SOURCE_REGISTER
'''

def parse(filepath):
    instructions = {}
    for line in open(filepath, "rt").readlines():
        if "MNEMONIC" in line:
            mnemonic = re.match("^.*\"(.*)\".*$", line).groups()[0]
            if "EXACT_MNEMONIC" in line:
                exact = True
            else:
                exact = False
        if "INSTRUCTION_CLASSIFICATION" in line:
            classification = line.strip().split(" ")[1]
        if "OPERAND_ENCODING" in line:
            encoding = " ".join(line.strip().split(" ")[1:])
        if "IMPLICIT_DESTINATION_POINTER_REGISTERS" in line:
            if "NO" in line:
                dest_ptr_regs = []
            else:
                dest_ptr_regs = [r.strip("\"") for r in re.findall("\"[a-z0-9]+\"", line)]
            instructions[mnemonic] = Instruction(mnemonic, exact, classification, encoding, dest_ptr_regs)
    return instructions

cache = {}
def get_metadata(mnemonic, arch):
    lib = cache.get(arch, None)
    if not lib:
        import os
        dirname = os.path.dirname(os.path.realpath(__file__))
        lib = parse("%s/metadisassembler_%s.h" % (dirname, arch))
        cache[arch] = lib 

    # look for exact match
    result = lib.get(mnemonic, None)
    if result:
        return result
    
    # look for inexact match
    result = []
    for m, meta in lib.items():
        if not meta.is_mnemonic_exact and m in mnemonic:
            result.append(meta) 
    if len(result) == 0:
        print "WARNING: no match for %s" % mnemonic
        return None
    elif len(result) > 1:
        print "WARNING: multiple matches for %s: %s" % (mnemonic, " ".join([m.mnemonic for m in result]))
        # pick the one that matches the most characters
        result = sorted(result, key=lambda x: len(x.mnemonic), reverse=True)
    return result[0]

import os
if __name__ == "__main__":
    by_encoding = {}
    by_classification = {}
    dirname = os.path.dirname(os.path.realpath(__file__))
    libs = {}
    for a in ["x86", "x64"]:
        libs[a] = parse('%s/metadisassembler_%s.h' % (dirname, a))
        print a
        for k,v in sorted(libs[a].items()):
            by_encoding[v.encoding] = by_encoding.get(v.encoding, []) + [k]
            by_classification[v.classification] = by_classification.get(v.classification, []) + [k]
    for k,v in by_encoding.items():
        print k, v
