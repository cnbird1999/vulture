'''
TODO
'''
import hashlib
import os
import re
import warnings

from lib.tools import AttrDict, memoized
from lib.msec import get_metadata


class ApportWrapperError(RuntimeError):
    '''
    Base class for errors in this module
    '''
    pass

class ProcMaps(list):
    '''
    A list of process address mappings. This object should only be instantiated
    when the Inferior is running, otherwise the string parsing may fail.
    '''
    _re_info_target = re.compile(r"""^\s+`(?P<file>.*?)',\s+file\s+type |
                                     ^\s+(?P<start>0x[0-9A-Fa-f]+)\s+-\s+
                                     (?P<end>0x[0-9A-Fa-f]+)\s+is\s+
                                     (?P<section>.*?)(\s+in\s+(?P<lib>.*?)(\.so[\.0-9]*)?)?$""", re.MULTILINE|re.VERBOSE)
    _re_gdb_sect_info = re.compile(r"^\s+(?P<start>0x[A-Fa-f0-9]+)->(?P<end>0x[A-Fa-f0-9]+) at 0x[A-Fa-f0-9]+: (?P<sect>[^\s]+)", re.MULTILINE)

    def __init__(self, mapstr):
        '''
        Queries the GDB Python API for the process address space, parses
        it, and appends it to self
        '''
        for line in mapstr.splitlines():
            cols = line.strip().split()
            start, end = [int(i, 16) for i in cols[0].split("-")]
            size = end - start
            perms = cols[1]
            offset = int(cols[2], 16)
            dev = cols[3]
            inode = cols[4]
            name = " ".join(cols[5:]).strip()
            ad = AttrDict(start=start, end=end, size=size,
                  offset=offset, name=name, perms=perms, dev=dev, inode=inode)
            self.append(ad)

    def findByName(self, name):
        '''
        Returns the process address mapping whose name matches name
        or None if no such mapping is found in self.
        '''
        for sect in self:
            if sect.name == name:
                return sect
        return None

    def findByAddr(self, addr):
        '''
        Returns the process address mapping that addr falls in,
        or None if no such mapping is found in self.
        '''
        result = None
        for sect in self:
            if sect.start <= addr < sect.end:
                if result is None or sect.size < result.size:
                    result = sect
        return result

class Instruction(object):
    '''
    A disassembled instruction. Notable attributes include:

    gdbstr - the original string of disassembly that was used to
        populate this instance
    operands - a list of Operand instances corresponding this
        Instruction's operands, ordered by operand_order
        See Operand class documentation for details
    mnemonic - the instruction mnemonic (ex: "pop" or "rep mov")
    dest - the destination Operand of this instruction (optional--
        only exists if this Instruction has a logical destination
        operand)
    source - the source Operand of this instruction (optional)
    aux - the aux Operand of this instruction (optional)
    '''
    _re_hex_int = re.compile(r"(0x[A-Fa-f0-9]+)")
    _re_dis_fail = re.compile(r""".*(<internal\sdisassembler\serror>|
                                     No\sfunction\scontains\sspecified\saddress).*""", re.VERBOSE)
    _x86_prefixes = ["rep", "repe", "repz", "repne", "repnz"]

    def __init__(self, gdbstr):
        '''
        Parses gdbstr to populate self; this method only covers parsing that 
        is common across processor architectures. The remainder of the parsing  
        is implemented in subclasses.
        '''
        self.gdbstr = gdbstr
        if self._re_dis_fail.match(self.gdbstr):
            raise GdbWrapperError("Disassembler error detected: {}".format(self.gdbstr))

    def __str__(self):
        return self.gdbstr

class x86Instruction(Instruction): 
    '''
    A disassembled Intel instruction. See Instruction class comments for more
    details.
    '''
    
    def __init__(self, gdbstr, target):
        '''
        Parses gdbstr to populate self.
        '''
        Instruction.__init__(self, gdbstr)
        self.target = target

        # strip indicator
        if self.gdbstr[0:2] == "=>":
            self.gdbstr = self.gdbstr[2:]

        # strip hints
        c = 0
        s = self.gdbstr
        self.gdbstr = ""
        for i in range(0, len(s)):
            if s[i] == "<":
                c += 1
                continue
            elif s[i] == ">":
                c -= 1
                continue
            if c > 0:
                continue
            self.gdbstr += s[i]

        toks = []
        for t in self.gdbstr.split():
            t = t.strip().strip(":")
            if t:
                toks.append(t)
        self.addr = int(toks[0], 16)

        # get mnemonic
        if toks[1] in self._x86_prefixes: # handle rep* prefixes
            self.mnemonic = " ".join(toks[1:3])
            self.inst = " ".join(toks[3:])
        else:
            self.mnemonic = toks[1]
            self.inst = " ".join(toks[2:])

        self.meta = get_metadata(self.mnemonic, self.target.arch())
        if not self.meta:
            raise NotImplementedError("no metadata for instruction '%s'" % self.mnemonic)
        self.classification = self.meta.classification

        # find pointers
        self.ptr_ops = self.analyze_operands()
        # TODO: make sure segment registers work as implemented

        if not self.ptr_ops:
            print "NOTE: no pointers"

    def get_pointer(self, op):
        for ops, val in self.ptr_ops:
            if op in ops:
                return val
        return None

    def get_read_pointer(self):
        return self.get_pointer("r")
            
    def get_write_pointer(self):
        return self.get_pointer("w")

    def analyze_operands(self):
        meta = self.meta
        re_reg = re.compile(r"%([a-z]{1,5}\d{0,2}[a-z]{0,1})")
        re_hex_int = re.compile(r"(-?0x[A-Fa-f0-9]+)")

        # get operand strings, obeying semantics of parenthesis 
        opstrs = []
        c = 0
        beginning = 0
        for i in range(0, len(self.inst)):
            if self.inst[i] == "(":
                c += 1
            elif self.inst[i] == ")":
                c -= 1
            if c != 0:
                continue

            if self.inst[i] == ",":
                opstrs.append(self.inst[beginning:i])
                beginning = i + 1
        opstrs.append(self.inst[beginning:len(self.inst)])

        op_pos = 0
        ops = []
        for opstr in opstrs:
            # if not a ptr, skip this operand
            if not ("(" in opstr or "*" in opstr):
                op_pos += 1
                continue

            # get integer constants and registers
            ints = re.findall(re_hex_int, opstr)
            regs = re.findall(re_reg, opstr)

            # compute pointer
            regvals = [self.target.registers()[reg] for reg in regs]
            ints = [int(i, 16) for i in ints]
            pointer_value = sum(regvals + ints)

            # determine operand type
            if meta.encoding == "COMBO_OPERANDS":
                if op_pos == 0: 
                    op_type = "r"
                if op_pos == 1:
                    op_type = "w"
                if len(opstrs) > 2:
                    raise NotImplementedError("TODO")
            elif meta.encoding == "COMBO_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE":
                if op_pos == 0:
                    op_type = "rw"
                if op_pos == 1:
                    op_type = "r"
                if len(opstrs) > 2:
                    raise NotImplementedError("TODO")
            elif meta.encoding == "COMBO_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE": #bitshift
                raise RuntimeError("Probably a false positive on a ptr -- (['bsf', 'bsr'])")
            elif meta.encoding == "SOURCE_OPERANDS_ONLY": # call
                op_type = "r"
            elif meta.encoding == "SOURCE_REGISTER": #push
                op_type = "r"
            elif meta.encoding == "COMBO_OPERANDS | DEST_OPERAND_IS_UNAFFECTED": # bit-test
                op_type = "r"
            elif meta.encoding == "DEST_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE": # inc, dec, etc.
                if op_pos == 0:
                    op_type = "rw"
                if len(opstrs) > 1:
                    raise NotImplementedError("TODO")
            elif meta.encoding == "NO_OPERANDS":
                print "WARNING: metadata says NO_OPERANDS but GDB has supplied some"
                continue
            elif meta.encoding == "DEST_REGISTER":
                raise RuntimeError("I must not understand what DEST_REGISTER means")
            elif meta.encoding == "SOURCE_OPERANDS": #div, jumps
                op_type = "r"
            elif meta.encoding == "SOURCE_POINTER | DEST_REGISTER": # xlat*
                op_type = "r"
            elif meta.encoding == ("COMBO_OPERANDS | DEST_OPERAND_IS_UNAFFECTED | " # cmp
                "DEST_OPERAND_IS_IMPLIED_SOURCE"):
                op_type = "r"
            elif meta.encoding == ("DEST_OPERANDS | SOURCE_REGISTER  | "
                    "DEST_OPERAND_IS_IMPLIED_SOURCE"): #cmpxchg
                op_type = "rw"
            elif meta.encoding == ("COMBO_OPERANDS | DEST_OPERAND_IS_IMPLIED_SOURCE | "  #test
                    "DEST_OPERAND_IS_UNAFFECTED"):
                op_type = "r"
            else:
                op_type = "u" # unknown

            ops.append((op_type, pointer_value))
            op_pos += 1

        # examine metadata for more pointers
        if len(self.meta.dest_ptr_regs) > 0:
            rp = self.meta.dest_ptr_regs[0]
            if self.meta.classification == "BLOCK_DATA_MOVE":
                val = self.target.counter() + self.target.registers()[rp]
                ops.append(("w", val))
            elif self.meta.classification == "STACK_PUSH":
                val = self.target.registers()[rp] + self.target.pointer_size()
                ops.append(("w", val))
            else:
                raise RuntimeError("unexpected destination pointers for instruction")

        return ops

    def __str__(self):
        out = ""
        for ops, val in self.ptr_ops:
            sect = self.target.procmaps().findByAddr(val)
            if sect:
                sect = "%s (%s)" % (sect.name, sect.perms)
            out += "['%s' -> 0x%0x (%s)] " % (ops, val, sect) 
        if out:
            out = " \t# %s" % out
        return "%s%s" % (self.gdbstr, out)


       
class Operand(object):
    '''
    A disassembled instruction operand that can be evaluated. Notable
    attributes include:

    gdbstr - the original string of disassembled operand that was used to
        populate this instance
    is_pointer - True if this operand represents a pointer, False otherwise.
        For example, "DWORD PTR [eax]" is considered a pointer, "eax" is not.
    regs - a list of strings representing the registers used in this Operand
    '''
    _re_addr = re.compile(r""".*\[(.*)\]  | # DWORD PTR [eax+0x1234]
                              .*\:(.*)      # DWORD PTR gs:0x18
                           """, re.VERBOSE)
    _re_p_regs = re.compile(r"eiz|riz")
    _re_regstrs = re.compile(
                r"""^([a-z]{1,5}\d{0,2}[a-z]{0,1})(?=\s*[\*\+-])                | # "(eax)+0x1234"
                     (?<=[\*\+-])\s*([a-z]{1,5}\d{0,2}[a-z]{0,1})(?=[\s*\*\+-]) | # "xmm5+(al)-0x1234"
                     (?<=[\*\+-])\s*([a-z]{1,5}\d{0,2}[a-z]{0,1})$              | # "eax+4* (esi)"
                    ^([a-z]{1,5}\d{0,2}[a-z]{0,1})$                               # "(edi)"
                 """, re.VERBOSE)
    _re_fpu_stack = re.compile(r"(st\(.*\))")

    def __init__(self, gdbstr):
        '''
        Parses gdbstr to populate self.  ex gdbstr="BYTE PTR es:[edi]"
        '''
        self.gdbstr = gdbstr
        gdbstr = gdbstr.split("<")[0] # get rid of "<addr resolutions>"

        # get addr
        addr = self._re_addr.match(gdbstr) # ignores segment regs
        if addr:
            self.is_pointer = True
            expr = [m for m in addr.groups() if m][0]
        else:
            self.is_pointer = False
            expr = gdbstr

        # eiz(x86) and riz(64) are pseudo-index registers that
        # the CPU always evaluates to 0. GDB types them as void (DNE)
        # which can cause a type error when evaluating expression via GDB,
        # so we substitute immediate zeros
        expr = self._re_p_regs.sub("0", expr)

        self.regs = [t.group() for t in self._re_regstrs.finditer(expr)]
        # prep for GDB evaluation. ex: "edx+0x12" becomes "$edx+0x12"
        self.expr = self._re_regstrs.sub(
                      (lambda mo: "${}".format([mg for mg in mo.groups() if mg][0])),
                      expr)

    def eval(self):
        '''
        Returns the integer value of this operand as evaluated by GDB. For
        example, if eax = 0x5 and this operand is DWORD PTR[eax + 0x100],
        eval would be 0x105 (a GDB.Value)
        '''
        if "mm" in " ".join(self.regs) or self._re_fpu_stack.match(self.gdbstr):
            return 0xDEADBEEF
        else:
            # Some GDBs (GDB 7.2 Fedora vs. Ubuntu/Debian) don't compare
            # signed and unsigned integer types consistently. gdb_uint
            # is a workaround
            return gdb_uint(gdb.parse_and_eval(self.expr))

    def __str__(self):
        out = self.gdbstr
        return self.gdbstr

class Backtrace(list):
    '''
    A backtrace composed of a list of GDB Frames (ordered from innermost to
    outermost) and other attributes, including:
    TODO

    hash - an object that can be used to determine uniqueness: note that
        Backtrace does not implement hashing from the Python data model (yet)
    abnormal_termination - set to True if GDB's backtrace unwind terminated
        abnormally, such as in the case of stack corruption
    '''
    def __init__(self, backtrace_text, blacklist=None, major_depth=5):
        list.__init__(self)
        self.blacklist = blacklist

        hc = 0
        i = 0
        major = "0"
        minor = "0"
        self.abnormal_termination = False

        for line in backtrace_text.splitlines():
            if "#" == line[0]:
                  self.append(Frame(line))

        for frame in self:

            # The check below is a workaround for a known libc/gdb runaway
            # backtrace issue, see
            # http://sourceware.org/ml/libc-alpha/2012-03/msg00573.html
            if frame.name() and "libc_start_main" in frame.name():
                break

            if not self._in_blacklist(frame):
                if hc < major_depth:
                    major = hashlib.md5((major + str(hash(frame))).encode()).hexdigest()
                minor = hashlib.md5((minor + str(hash(frame))).encode()).hexdigest()
                hc += 1
            else:
                frame.blacklisted = True

            i += 1

        self.hash = AttrDict(major=major, minor=minor)

    def _in_blacklist(self, frame):
        '''
        Returns True if frame is in self.blacklist, False otherwise.
        '''
        if not self.blacklist:
            return False
        if frame.name() in self.blacklist.functions:
            return True
        if frame.mapped_region and \
           self.blacklist.map_regex.match(frame.mapped_region.name):
            return True
        return False

    def __str__(self):
        result = [str(f) for f in self]
        return "\n".join(result)

class Frame(object):
    def __init__(self, line):
        self.blacklisted = False
        self.mapped_region = None
        self.line = line

        # #0  __memcpy_sse2_unaligned () at ../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:33
        # #1  0x00007f7d040df3ee in memcpy (__len=960, __src=0x0, __dest=<optimized out>) at /usr/include/x86_64-linux-gnu/bits/string3.h:51
        words = line.split()
        if words[1][0:2] == "0x": # no sym
            addr = int(words[1], 16)
            assert(words[2] == "in") # such hack, need check
            name = words[3]
        elif words[2][0] == "(":
            name = words[1]
            addr = None
        else:
            name = line # better than nothing
            addr = None

        self._name = name
        self.addr = addr

    def __str__(self):
        desc = self.name()
        if self.blacklisted:
            desc += " (BL)"
        return desc

    def __hash__(self):
        return hash(self.line)

    def name(self):
        return self._name


class Target(object):
    '''
    A wrapper for a Linux GDB Inferior. Includes of various convenience
    methods used for classification.

    WARNING: Methods in this object may change the state of GDB. For
    example, the disassembly flavor may be left as "intel"
    after this code is executed.
    '''
    _re_info_frame = re.compile(r"""^\s*eip\s=\s([^\s;]*)(?:\sin\s)? # addr
                                                ([^\s;]*) # fname
                                                ([^\s;]*) # source_file:line
                                 """, re.VERBOSE)
    _re_gdb_info_sym = re.compile(r"""^\s*(?P<sym>.*?)\s+\+\s+(?P<off>[0-9]+)\s+
                                       in\s+section\s+\.text(\s+
                                       of\s+(?P<lib>.*?)\s*)?$""", re.VERBOSE)
    _re_gdb_addr_bit = re.compile(r"^gdbarch_dump: addr_bit = ([0-9]+)$", re.MULTILINE)
    _re_gdb_osabi = re.compile(r"\(currently \"(.*)\"\)")
    _re_gdb_arch = re.compile(r"\(currently\s+(.+)\)")

    # these functions and libs are not considered to be at fault for a crash
    blacklist = AttrDict(functions=("__kernel_vsyscall", "abort", "raise",
                                    "malloc", "free", "*__GI_abort",
                                    "*__GI_raise", "malloc_printerr",
                                    "__libc_message", "_int_malloc",
                                    "_int_free", '__kernel_vsyscall', 'abort', 'raise', 'malloc', 'free', 
                                    '*__GI_abort', '*__GI_raise', 'malloc_printerr', '__libc_message',
                                    'malloc_consolidate', '_int_malloc', '__libc_calloc',
                                    '_dl_new_object', '_dl_map_object_from_fd', '_dl_catch_error',
                                    '_dl_open', 'do_dlopen', 'dlerror_run', '*__GI___libc_dlopen_mode',
                                    '_dl_map_object', 'dl_open_worker', 'munmap_chunk', '*__GI___backtrace',
                                    '_dl_addr_inside_object', '_int_free', '*__GI___libc_free',
                                    '__malloc_assert', 'sYSMALLOc', '_int_realloc', '*__GI___libc_malloc',
                                    '*__GI___libc_realloc', '_int_memalign', '*__GI___libc_memalign',
                                    '__posix_memalign', 'malloc_consolidate', '__libc_malloc', '__libc_realloc'),
                         map_regex=re.compile(r".*/libc(\.|-).*|.*/libm(\.|-).*"))

    def __init__(self, bug_dirpath):
        basis = [('disassembly_text', '/Disassembly.txt'),
                 ('stacktrace_text', '/Stacktrace.txt'),
                 ('registers_text', '/Registers.txt'),
                 ('procmap_text', '/ProcMaps.txt'),
                 ('signal_text', '/signal.txt')]
        for k, v in basis:
            setattr(self, k, open(bug_dirpath + v, "rt").read())
        #print self.current_instruction()
        #print self.registers()
        #print "%x" % self.pc()
        #print self.procmaps()
        #print self.backtrace()
        #print self.signal()

    @memoized
    def arch(self):
        if "rip" in self.registers():
            return "x64"
        elif "eip" in self.registers():
            return "x86"
        else:
            raise NotImplementedError("Unknown arch: rip/eip not found")

    @memoized
    def registers(self):
        regs = {}
        for line in self.registers_text.splitlines():
            parts = line.strip().split()
            name = parts[0]
            val = int(parts[1], 16)
            regs[name] = val
        return regs


    @memoized
    def backtrace(self):
        return Backtrace(self.stacktrace_text, self.blacklist)

    def hash(self):
        return self.backtrace().hash

    @memoized
    def procmaps(self):
        return ProcMaps(self.procmap_text)

    @memoized
    def faulting_frame(self):
        for frame in self.backtrace():
            if not frame.blacklisted:
                return frame
        warnings.warn("All frames blacklisted")
        return None

    @staticmethod
    def sym_addr(sym):
        try:
            return gdb_uint(gdb.parse_and_eval(str(sym)))
        except gdb.error:
            return None

    @memoized
    def current_instruction(self):
        import re
        re_hex_int = re.compile(r"^(0x[A-Fa-f0-9]+).*$")
        lines = [l.strip() for l in self.disassembly_text.splitlines()]
        inst = None
        for i in range(0, len(lines)):
            if "=>" in lines[i]:
                inst = lines[i]
                # handle long instructions that break across lines
                j = 1 
                while not re.match(re_hex_int, lines[i+j]): 
                    inst += lines[i+j]
                    j += 1
                break

        # if no "=>", then try the first line
        if not inst:
            inst = lines[0]
            # handle long instructions that break across lines
            for i in range(1, len(lines)):
                if re.match(re_hex_int, lines[i]): 
                    break
                inst += lines[i]

        return x86Instruction(inst, self)

    @memoized
    def pc(self):
        if self.arch() == "x86":
            return self.registers()['eip']
        else:
            return self.registers()['rip']

    @memoized
    def stack_pointer(self):
        if self.arch() == "x86":
            return self.registers()['esp']
        else:
            return self.registers()['rsp']

    @memoized
    def counter(self):
        if self.arch() == "x86":
            return self.registers()['ecx']
        else:
            return self.registers()['rcx']

    @memoized
    def pid(self):
        return gdb.inferiors()[0].pid

    @memoized
    def pointer_size(self):
        if self.arch() == "x86":
            return 4
        elif self.arch() == "x64":
            return 8
        raise NotImplementedError("unsupported arch")

    @memoized
    def signal(self):
        return self.signal_text.strip()

    @memoized
    def si_addr(self):
        str(gdb.parse_and_eval("$_siginfo._sifields._sigfault.si_addr"))
        return gdb_uint(gdb.parse_and_eval(
            "$_siginfo._sifields._sigfault.si_addr"))
