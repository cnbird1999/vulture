'''
TODO
'''
import hashlib
import os
import re
import warnings

from lib.tools import AttrDict, memoized
from lib.msec import get_metadata


class ApportWrapperError(RuntimeError):
    '''
    Base class for errors in this module
    '''
    pass

class ProcMaps(list):
    '''
    A list of process address mappings. This object should only be instantiated
    when the Inferior is running, otherwise the string parsing may fail.
    '''
    _re_info_target = re.compile(r"""^\s+`(?P<file>.*?)',\s+file\s+type |
                                     ^\s+(?P<start>0x[0-9A-Fa-f]+)\s+-\s+
                                     (?P<end>0x[0-9A-Fa-f]+)\s+is\s+
                                     (?P<section>.*?)(\s+in\s+(?P<lib>.*?)(\.so[\.0-9]*)?)?$""", re.MULTILINE|re.VERBOSE)
    _re_gdb_sect_info = re.compile(r"^\s+(?P<start>0x[A-Fa-f0-9]+)->(?P<end>0x[A-Fa-f0-9]+) at 0x[A-Fa-f0-9]+: (?P<sect>[^\s]+)", re.MULTILINE)

    def __init__(self, mapstr):
        '''
        Queries the GDB Python API for the process address space, parses
        it, and appends it to self
        '''
        for line in mapstr.splitlines():
            cols = line.strip().split()
            start, end = [int(i, 16) for i in cols[0].split("-")]
            size = end - start
            perms = cols[1]
            offset = int(cols[2], 16)
            dev = cols[3]
            inode = cols[4]
            name = " ".join(cols[5:])
            ad = AttrDict(start=start, end=end, size=size,
                  offset=offset, name=name, perms=perms, dev=dev, inode=inode)
            self.append(ad)

    def __str__(self):
        result = []
        for m in self:
            result += ["%s\t%s\t%s" % (m.start, m.end, m.name)]
        return "\n".join(result)

    def findByName(self, name):
        '''
        Returns the process address mapping whose name matches name
        or None if no such mapping is found in self.
        '''
        for sect in self:
            if sect.name == name:
                return sect
        return None

    def findByAddr(self, addr):
        '''
        Returns the process address mapping that addr falls in,
        or None if no such mapping is found in self.
        '''
        result = None
        for sect in self:
            if sect.start <= addr < sect.end:
                if result is None or sect.size < result.size:
                    result = sect
        return result

class Instruction(object):
    '''
    A disassembled instruction. Notable attributes include:

    gdbstr - the original string of disassembly that was used to
        populate this instance
    operands - a list of Operand instances corresponding this
        Instruction's operands, ordered by operand_order
        See Operand class documentation for details
    mnemonic - the instruction mnemonic (ex: "pop" or "rep mov")
    dest - the destination Operand of this instruction (optional--
        only exists if this Instruction has a logical destination
        operand)
    source - the source Operand of this instruction (optional)
    aux - the aux Operand of this instruction (optional)
    '''
    _re_hex_int = re.compile(r"(0x[A-Fa-f0-9]+)")
    _re_dis_fail = re.compile(r""".*(<internal\sdisassembler\serror>|
                                     No\sfunction\scontains\sspecified\saddress).*""", re.VERBOSE)
    _x86_prefixes = ["rep", "repe", "repz", "repne", "repnz"]

    def __init__(self, gdbstr):
        '''
        Parses gdbstr to populate self; this method only covers parsing that 
        is common across processor architectures. The remainder of the parsing  
        is implemented in subclasses.
        '''
        self.gdbstr = gdbstr
        if self._re_dis_fail.match(self.gdbstr):
            raise GdbWrapperError("Disassembler error detected: {}".format(self.gdbstr))
        self.operands = []
        self.source = None
        self.dest = None
        self.aux = None

    def __str__(self):
        return self.gdbstr

class x86Instruction(Instruction): 
    '''
    A disassembled Intel instruction. See Instruction class comments for more
    details.
    '''
    
    def __init__(self, gdbstr, arch):
        '''
        Parses gdbstr to populate self.
        '''
        Instruction.__init__(self, gdbstr)
        # strip indicator
        if self.gdbstr[0:2] == "=>":
            self.gdbstr = self.gdbstr[2:]

        # strip hints
        c = 0
        s = self.gdbstr
        self.gdbstr = ""
        for i in range(0, len(s)):
            if s[i] == "<":
                c += 1
                continue
            elif s[i] == ">":
                c -= 1
                continue
            if c > 0:
                continue
            self.gdbstr += s[i]

        toks = []
        for t in self.gdbstr.split():
            t = t.strip().strip(":")
            if t:
                toks.append(t)
        self.addr = int(toks[0], 16)

        # get mnemonic
        if toks[1] in self._x86_prefixes: # handle rep* prefixes
            self.mnemonic = " ".join(toks[1:3])
            self.inst = " ".join(toks[3:])
        else:
            self.mnemonic = toks[1]
            self.inst = " ".join(toks[2:])

        meta = get_metadata(self.mnemonic, arch)
        # only care about pointers
        # do simple math: 0x8(%rax)  , bail on others

        # find pointers
        # types: *0x8(%eax), -0x9(%ebx), (%ebx), (%eax,%ebx,%ecx)
        # need to know if point operand is in "src" or "dst" position, then apply MSEC logic to determin if is a source or dest AV
        # => 0x7ffb4e43a318:    callq  *0x30(%r15)
        # call   *%ecx
        # 0x287d91 <empathy_account_settings_get_uint32+81>:  jmp    *%eax
        # 0xb7c6b266 <v4l1_open+69>:  mov    -0x1ec(%ebp),%esi
        #    0x7fde990d904d <connman_network_set_uint8+13>: mov    %rbp,-0x10(%rsp)
        re_reg = re.compile(r"([a-z]{1,5}\d{0,2}[a-z]{0,1})")
        re_hex_int = re.compile(r"(-0x[A-Fa-f0-9]+)")
        print self.inst
        opstrs = self.inst.split(",")
        inst_has_pointers = False
        for opstr in opstrs:
            # count dereferences in this operand
            for c in ["(", "*"]:
                if c in opstr
                    derefs += 1
            if not derefs: # no pointers
                continue
            inst_has_pointers = True

            # get integer constants and register values
            ints = re.findall(re_hex_int, opstr)
            regs = re.findall(re_reg, opstr)
            regvals = []
            for reg in regs:
                regvals.append(self.registers()[reg])
            import pdb; pdb.set_trace()


            
            # get arguments for pointer calculation
            # lookup any register arguments
            # add (with negatives) arguments for pointer calculation TODO: make sure segment registers work this way
            pass
        import pdb; pdb.set_trace()

        '''
        copy/paste from above as a baseline for pointer-finding
        c = 0
        s = self.gdbstr
        self.gdbstr = ""
        for i in range(0, len(s)):
            if s[i] == "<":
                c += 1
                continue
            elif s[i] == ">":
                c -= 1
                continue
            if c > 0:
                continue
            self.gdbstr += s[i]
        '''


        #pos = self.inst.find("(%")
        #if pos == -1:
        #    msg = "WARNING: no pointer found in %s" % self.inst
        #    print msg
        #    raise NotImplementedError(msg)
        

        
        '''
             
        if self.inst == "": # handle "ret", "iret", et al.
            raise NotImplementedException("TODO")
        for opstr in self.inst.split(","):
            regs = re.findall("%([a-z]+)")
        '''

        # get operands
        self.operands = [Operand(o) for o in self.inst.split(",")]
        for a, o in zip(("dest", "source", "aux"), self.operands):
            setattr(self, a, o)
       
class Operand(object):
    '''
    A disassembled instruction operand that can be evaluated. Notable
    attributes include:

    gdbstr - the original string of disassembled operand that was used to
        populate this instance
    is_pointer - True if this operand represents a pointer, False otherwise.
        For example, "DWORD PTR [eax]" is considered a pointer, "eax" is not.
    regs - a list of strings representing the registers used in this Operand
    '''
    _re_addr = re.compile(r""".*\[(.*)\]  | # DWORD PTR [eax+0x1234]
                              .*\:(.*)      # DWORD PTR gs:0x18
                           """, re.VERBOSE)
    _re_p_regs = re.compile(r"eiz|riz")
    _re_regstrs = re.compile(
                r"""^([a-z]{1,5}\d{0,2}[a-z]{0,1})(?=\s*[\*\+-])                | # "(eax)+0x1234"
                     (?<=[\*\+-])\s*([a-z]{1,5}\d{0,2}[a-z]{0,1})(?=[\s*\*\+-]) | # "xmm5+(al)-0x1234"
                     (?<=[\*\+-])\s*([a-z]{1,5}\d{0,2}[a-z]{0,1})$              | # "eax+4* (esi)"
                    ^([a-z]{1,5}\d{0,2}[a-z]{0,1})$                               # "(edi)"
                 """, re.VERBOSE)
    _re_fpu_stack = re.compile(r"(st\(.*\))")

    def __init__(self, gdbstr):
        '''
        Parses gdbstr to populate self.  ex gdbstr="BYTE PTR es:[edi]"
        '''
        self.gdbstr = gdbstr
        gdbstr = gdbstr.split("<")[0] # get rid of "<addr resolutions>"

        # get addr
        addr = self._re_addr.match(gdbstr) # ignores segment regs
        if addr:
            self.is_pointer = True
            expr = [m for m in addr.groups() if m][0]
        else:
            self.is_pointer = False
            expr = gdbstr

        # eiz(x86) and riz(64) are pseudo-index registers that
        # the CPU always evaluates to 0. GDB types them as void (DNE)
        # which can cause a type error when evaluating expression via GDB,
        # so we substitute immediate zeros
        expr = self._re_p_regs.sub("0", expr)

        self.regs = [t.group() for t in self._re_regstrs.finditer(expr)]
        # prep for GDB evaluation. ex: "edx+0x12" becomes "$edx+0x12"
        self.expr = self._re_regstrs.sub(
                      (lambda mo: "${}".format([mg for mg in mo.groups() if mg][0])),
                      expr)

    def eval(self):
        '''
        Returns the integer value of this operand as evaluated by GDB. For
        example, if eax = 0x5 and this operand is DWORD PTR[eax + 0x100],
        eval would be 0x105 (a GDB.Value)
        '''
        if "mm" in " ".join(self.regs) or self._re_fpu_stack.match(self.gdbstr):
            return 0xDEADBEEF
        else:
            # Some GDBs (GDB 7.2 Fedora vs. Ubuntu/Debian) don't compare
            # signed and unsigned integer types consistently. gdb_uint
            # is a workaround
            return gdb_uint(gdb.parse_and_eval(self.expr))

    def __str__(self):
        return self.gdbstr

class Backtrace(list):
    '''
    A backtrace composed of a list of GDB Frames (ordered from innermost to
    outermost) and other attributes, including:
    TODO

    hash - an object that can be used to determine uniqueness: note that
        Backtrace does not implement hashing from the Python data model (yet)
    abnormal_termination - set to True if GDB's backtrace unwind terminated
        abnormally, such as in the case of stack corruption
    '''
    def __init__(self, backtrace_text, blacklist=None, major_depth=5):
        list.__init__(self)
        self.blacklist = blacklist

        hc = 0
        i = 0
        major = "0"
        minor = "0"
        self.abnormal_termination = False

        for line in backtrace_text.splitlines():
            # #0  __memcpy_sse2_unaligned () at ../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:33
            # #1  0x00007f7d040df3ee in memcpy (__len=960, __src=0x0, __dest=<optimized out>) at /usr/include/x86_64-linux-gnu/bits/string3.h:51
            if "#" == line[0]:
                words = line.split()
                if words[1][0:2] == "0x": # no sym
                    addr = int(words[1], 16)
                    assert(words[2] == "in") # such hack, need check
                    name = words[3]
                else:
                    name = words[1]
                    assert(words[2][0] == "(") # such hack, need check
                    addr = None
                if name == "??":
                    name = None
                self.append(Frame(name, addr))

        for frame in self:

            # The check below is a workaround for a known libc/gdb runaway
            # backtrace issue, see
            # http://sourceware.org/ml/libc-alpha/2012-03/msg00573.html
            if frame.name() and "libc_start_main" in frame.name():
                break

            if not self._in_blacklist(frame):
                if hc < major_depth:
                    major = hashlib.md5((major + str(frame)).encode()).hexdigest()
                minor = hashlib.md5((minor + str(frame)).encode()).hexdigest()
                hc += 1
            else:
                frame.blacklisted = True

            i += 1

        self.hash = AttrDict(major=major, minor=minor)

    def _in_blacklist(self, frame):
        '''
        Returns True if frame is in self.blacklist, False otherwise.
        '''
        if not self.blacklist:
            return False
        if frame.name() in self.blacklist.functions:
            return True
        if frame.mapped_region and \
           self.blacklist.map_regex.match(frame.mapped_region.name):
            return True
        return False

    def __str__(self):
        result = [str(f) for f in self]
        return "\n".join(result)

class Frame(object):
    def __init__(self, name, addr):
        self.blacklisted = False
        self._name = name
        self.addr = addr
        self.mapped_region = None

    def __str__(self):
        desc = self.name()
        if self.blacklisted:
            desc += " (BL)"
        return desc

    def name(self):
        return self._name


class Target(object):
    '''
    A wrapper for a Linux GDB Inferior. Includes of various convenience
    methods used for classification.

    WARNING: Methods in this object may change the state of GDB. For
    example, the disassembly flavor may be left as "intel"
    after this code is executed.
    '''
    _re_info_frame = re.compile(r"""^\s*eip\s=\s([^\s;]*)(?:\sin\s)? # addr
                                                ([^\s;]*) # fname
                                                ([^\s;]*) # source_file:line
                                 """, re.VERBOSE)
    _re_gdb_info_sym = re.compile(r"""^\s*(?P<sym>.*?)\s+\+\s+(?P<off>[0-9]+)\s+
                                       in\s+section\s+\.text(\s+
                                       of\s+(?P<lib>.*?)\s*)?$""", re.VERBOSE)
    _re_gdb_addr_bit = re.compile(r"^gdbarch_dump: addr_bit = ([0-9]+)$", re.MULTILINE)
    _re_gdb_osabi = re.compile(r"\(currently \"(.*)\"\)")
    _re_gdb_arch = re.compile(r"\(currently\s+(.+)\)")

    # these functions and libs are not considered to be at fault for a crash
    blacklist = AttrDict(functions=("__kernel_vsyscall", "abort", "raise",
                                    "malloc", "free", "*__GI_abort",
                                    "*__GI_raise", "malloc_printerr",
                                    "__libc_message", "_int_malloc",
                                    "_int_free", '__kernel_vsyscall', 'abort', 'raise', 'malloc', 'free', 
                                    '*__GI_abort', '*__GI_raise', 'malloc_printerr', '__libc_message',
                                    'malloc_consolidate', '_int_malloc', '__libc_calloc',
                                    '_dl_new_object', '_dl_map_object_from_fd', '_dl_catch_error',
                                    '_dl_open', 'do_dlopen', 'dlerror_run', '*__GI___libc_dlopen_mode',
                                    '_dl_map_object', 'dl_open_worker', 'munmap_chunk', '*__GI___backtrace',
                                    '_dl_addr_inside_object', '_int_free', '*__GI___libc_free',
                                    '__malloc_assert', 'sYSMALLOc', '_int_realloc', '*__GI___libc_malloc',
                                    '*__GI___libc_realloc', '_int_memalign', '*__GI___libc_memalign',
                                    '__posix_memalign', 'malloc_consolidate', '__libc_malloc', '__libc_realloc'),
                         map_regex=re.compile(r".*/libc(\.|-).*|.*/libm(\.|-).*"))

    def __init__(self, bug_dirpath):
        basis = [('disassembly_text', '/Disassembly.txt'),
                 ('stacktrace_text', '/Stacktrace.txt'),
                 ('registers_text', '/Registers.txt'),
                 ('procmap_text', '/ProcMaps.txt'),
                 ('signal_text', '/signal.txt')]
        for k, v in basis:
            setattr(self, k, open(bug_dirpath + v, "rt").read())
        print self.current_instruction()
        #print self.registers()
        #print "%x" % self.pc()
        #print self.procmaps()
        #print self.backtrace()
        #print self.signal()

    @memoized
    def arch(self):
        if "rip" in self.registers():
            return "x64"
        elif "eip" in self.registers():
            return "x86"
        else:
            raise NotImplementedError("Unknown arch: rip/eip not found")

    @memoized
    def registers(self):
        regs = {}
        for line in self.registers_text.splitlines():
            parts = line.strip().split()
            name = parts[0]
            val = int(parts[1], 16)
            regs[name] = val
        return regs


    @memoized
    def backtrace(self):
        return Backtrace(self.stacktrace_text, self.blacklist)

    def hash(self):
        return self.backtrace().hash

    @memoized
    def procmaps(self):
        return ProcMaps(self.procmap_text)

    @memoized
    def faulting_frame(self):
        for frame in self.backtrace():
            if not frame.blacklisted:
                return frame
        warnings.warn("All frames blacklisted")
        return None

    @staticmethod
    def sym_addr(sym):
        try:
            return gdb_uint(gdb.parse_and_eval(str(sym)))
        except gdb.error:
            return None

    @memoized
    def current_instruction(self):
        import re
        re_hex_int = re.compile(r"^(0x[A-Fa-f0-9]+).*$")
        lines = [l.strip() for l in self.disassembly_text.splitlines()]
        inst = None
        for i in range(0, len(lines)):
            if "=>" in lines[i]:
                inst = lines[i]
                # handle long instructions that break across lines
                j = 1 
                while not re.match(re_hex_int, lines[i+j]): 
                    inst += lines[i+j]
                    j += 1
                break

        # if no "=>", then try the first line
        if not inst:
            inst = lines[0]
            # handle long instructions that break across lines
            for i in range(1, len(lines)):
                if re.match(re_hex_int, lines[i]): 
                    break
                inst += lines[i]

        return x86Instruction(inst, self.arch())

    @memoized
    def pc(self):
        if self.arch() == "x86":
            return self.registers()['eip']
        else:
            return self.registers()['rip']

    @memoized
    def stack_pointer(self):
        return gdb_uint(gdb.parse_and_eval("$sp"))

    @memoized
    def pid(self):
        return gdb.inferiors()[0].pid

    @memoized
    def pointer_size(self):
        return int(self._re_gdb_addr_bit.search(
                       gdb.execute("maint print architecture", False, True)).group(1)) / 8

    @memoized
    def signal(self):
        return self.signal_text.strip()

    @memoized
    def si_addr(self):
        str(gdb.parse_and_eval("$_siginfo._sifields._sigfault.si_addr"))
        return gdb_uint(gdb.parse_and_eval(
            "$_siginfo._sifields._sigfault.si_addr"))
