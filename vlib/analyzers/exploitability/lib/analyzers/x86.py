'''
Contains analyzers used to match rules that are used to classify the state
of a GDB inferior and some helper functions.
'''

import re
import signal

from lib.tools import memoized

class Analyzer(object):
    '''
    Contains methods that analyze a Target (a Linux GDB inferior state) to 
    determine properties of the Target (such as how the application crashed).
    The methods correspond to "rules" defined in rules.py.
    If an analyzer method returns True the rule is considered a match
    to the GDB inferior's state, otherwise the rule is not considered a match.
    This class contains logic for x86 platforms (the "original" target of the
    exploitable plugin), and is inherited to implement logic for other 
    platforms.
    '''

    def __init__(self, target):
        self.target = target

    # EXPLOITABLE matching methods follow

    @memoized
    def isBranchAvNotNearNull(self):
        return self.isBranchAv() and \
            not self.isNearNull(self.faultingAddress())

    @memoized
    def isReturnAv(self):
        return self.isAccessViolationSignal() and \
            (self.target.current_instruction().classification == "RETURN")

    @memoized
    def isSegFaultOnPcNotNearNull(self):
        return self.isSegFaultOnPc() and not self.isFaNearNull()

    @memoized
    def isErrorWhileExecutingFromStack(self):
        if self.isBenign():
            return False
        sect = self.target.procmaps().findByAddr(self.target.pc())
        if sect and "[stack" in sect.name: # maybe check threadstacks too?
            return True
        return False

    @memoized
    def isStackBufferOverflow(self):
        # Some versions of libc attempt to print a backtrace when
        # __stack_chk_fail is invoked, which may cause a SIGSEGV in the SIGABRT
        # handler. This is a a known issue, see CVE 2010-3192.
        # Thus the isAbortSignal(target) check must be omitted.
 
        sequences = [["__fortify_fail", "__stack_chk_fail"],
                     ["__GI___fortify_fail", "__stack_chk_fail"]]
        for seq in sequences:
            if self.isInBacktrace(seq, "/libc"):
                return True
        return False

    @memoized
    def isPossibleStackCorruption(self):
        return False # TODO delete
        if self.isBenign():
            return False
    
        if self.isStackOverflow():
            return False
        pm = self.target.procmaps().findByAddr(self.target.stack_pointer())
        if not pm or ("[stack" not in pm.name):
            return True
   
        # need to add logic to map ST frames for this to work
        # bt = self.target.backtrace()
        # for fr in bt[1:]:
    
        return False

    @memoized
    def isWriteAvNotNearNull(self):
        return self.isWriteAv() and not self.isFaNearNull()

    @memoized
    def isHeapError(self):
        libc_bts = [ ["abort", "__libc_message", "malloc_printerr"], # mcheck_print
                 ["abort", "malloc_printerr"], # mcheck_noprint
                 ["free"],
                 ["malloc"],
                 ["__malloc_assert"] ]
    
        for seq in libc_bts:
            if self.isInBacktrace(seq, "/libc"):
                return True
        return False

    # PROBABLY_EXPLOITABLE matching methods follow

    @memoized
    def isStackOverflow(self):
        if not self.isAccessViolationSignal() or not self.target.current_instruction():
            return False

        if not self.target.current_instruction().classification == "STACK_PUSH":
            return False
        # verify the stack pointer is outside the default stack region
        pm = self.target.procmaps().findByAddr(self.target.stack_pointer())
        if pm and pm.name == "[stack]":
            return False

        return True

    @memoized
    def isMalformedInstructionSignal(self):
        siglist = ["SIGILL", "SIGSYS"]
        return self.isSignalInList(siglist)

    @memoized
    def isSegFaultOnPcNearNull(self):
        return self.isSegFaultOnPc() and self.isFaNearNull()

    @memoized
    def isBranchAvNearNull(self):
        return self.isBranchAv() and self.isNearNull(self.faultingAddress())

    @memoized
    def isBlockMove(self):
        if self.isBenign() or not self.target.current_instruction():
            return False
        return self.target.current_instruction().meta.classification == "BLOCK_DATA_MOVE"

    @memoized
    def isRepAv(self):
        if self.isAccessViolationSignal() and self.target.current_instruction().mnemonic[:3] == "rep":
            return True
        return False

    @memoized
    def isWriteAvNearNull(self):
        return self.isWriteAv() and self.isFaNearNull()

    # PROBABLY_NOT_EXPLOITABLE matching methods follow

    @memoized
    def isBenignSignal(self):
       siglist = ["SIGTERM", "SIGINT", "SIGQUIT", "SIGKILL", "SIGHUP",
              "SIGALRM", "SIGVTALRM", "SIGPROF", "SIGIO", "SIGURG",
              "SIGPOLL", "SIGUSR1", "SIGUSR2", "SIGWINCH", "SIGINFO",
              "SIGCHLD", "SIGCONT", "SIGSTOP", "SIGTSTP"]
       return self.isSignalInList(siglist)

    @memoized
    def isReadAvNotNearNull(self):
        return self.isReadAv() and not self.isFaNearNull()

    @memoized
    def isFloatingPointException(self):
        siglist = ["SIGFPE"]
        return self.isSignalInList(siglist)

    # UNKNOWN matching methods follow

    @memoized
    def isReadAvNearNull(self):
        return self.isReadAv() and self.isFaNearNull()

    @memoized
    def isAbortSignal(self):
        return self.isOnSignal() and self.target.signal() == "SIGABRT"

    @memoized
    def isAccessViolationSignal(self):
         return self.isSignalInList(["SIGSEGV", "SIGBUS"])

    @memoized
    def isUncategorizedSignal(self):
        return not (self.isAccessViolationSignal() or self.isAbortSignal() \
            or self.isBenignSignal() or self.isFloatingPointException() \
            or self.isMalformedInstructionSignal())

    '''
    Helpers
    The following functions are called by multiple analyzers and are not 
    directly associated with a rule.
    '''

    @memoized
    def isOnSignal(self):
        return bool(self.target.signal())

    @memoized
    def isSignalInList(self, siglist):
        '''
        TODO
        '''
        for s in siglist:
            if s == self.target.signal():
                return True
        return False

    def isNearNull(self, addr):
        '''
        Returns True of addr is near NULL, False otherwise
        '''
        if addr < 64 * 1024: # same as !exploitable
            return True
        return False

    @memoized
    def isInBacktrace(self, fnames, region=None):
        i = 0
        for fr in self.target.backtrace():
            if fr.name() and fnames[i] == fr.name(): # note: delete some logic here
                i = i + 1
                if i == len(fnames):
                    return True
            else:
                i = 0
        return False

    @memoized
    def isFaNearNull(self):
        return self.isNearNull(self.faultingAddress())

    @memoized
    def isBenign(self):
        return self.isOnSignal() and self.isBenignSignal()

    @memoized
    def isJumpInstruction(self):
        ins = self.target.current_instruction()
        jumps = ["ja", "jae", "jb", "jbe", "jc", "jcxz", "je", "jecxz", "jg",
                "jge", "jl", "jle", "jmp", "jna", "jnae", "jnb", "jnbe", "jnc",
                "jne", "jng", "jnge", "jnl", "jnle", "jno", "jnp", "jns", "jp",
                "js", "jz"]
        return ins and ins.mnemonic in jumps

    @memoized
    def isBranchAv(self):
        if not self.isAccessViolationSignal():
            return False
        return self.target.current_instruction().classification == "BRANCH"

    @memoized
    def faultingAddress(self):
        if self.isAccessViolationSignal():
            addrs = []
            inst = self.target.current_instruction()
            addr = inst.get_read_pointer()
            if addr:
                pm = self.target.procmaps().findByAddr(addr)
                if not pm:
                    addrs.append(addr) # out-of-bounds read
                elif pm:
                    if "r" not in pm.perms:
                        addrs.append(addr) # permission violation
                    elif inst.classification == "BRANCH" and ("x" not in pm.perms):
                        addrs.append(addr) # execute violation

            addr = inst.get_write_pointer()
            if addr and (addr not in addrs):
                pm = self.target.procmaps().findByAddr(addr)
                if not pm:
                    addrs.append(addr) # out-of-bounds write
                elif pm and "w" not in pm.perms:
                    addrs.append(addr) # permission violation

            if len(addrs) > 1:
                raise RuntimeError("ambiguous: all addrs are not in proc maps: %s" % str(addrs))
            if len(addrs) == 1:
                return addrs[0]
        raise NotImplementedError("can't figure out faulting address")

    @memoized
    def isSegFaultOnPc(self):
        if not self.isAccessViolationSignal():
            return False
        sect = self.target.procmaps().findByAddr(self.target.pc())
        if not sect:
            return True
        if "x" not in sect.perms:
            return True
        return False

    @memoized
    def isWriteAv(self):
        if not self.isAccessViolationSignal():
            return False
        addr = self.target.current_instruction().get_write_pointer()
        if not addr:
            return False
        sect = self.target.procmaps().findByAddr(addr)
        if not sect:
            return True
        if "w" not in sect.perms:
            return True
        return False

    @memoized
    def isReadAv(self):
        if not self.isAccessViolationSignal():
            return False
        addr = self.target.current_instruction().get_read_pointer()
        if not addr:
            return False
        sect = self.target.procmaps().findByAddr(addr)
        if not sect:
            return True
        if "r" not in sect.perms:
            return True
        return False

    @memoized
    def isUseAfterFree(self):
        return False
